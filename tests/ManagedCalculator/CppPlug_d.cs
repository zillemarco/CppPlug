//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppPlug
{
    public unsafe partial class CPluginInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public byte _ownsInfos;

            [FieldOffset(4)]
            public global::System.IntPtr _pluginInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CPluginInfo@@QAE@PAUPluginInfo@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr pluginInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CPluginInfo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CPluginInfo@@QAE@PBD0P6APAXPAUModuleInfo@@HPAX@ZP6AX2@ZP6A_N202@ZP6APBD2@ZP6AX20@Z@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string service, global::System.IntPtr createPluginFunc, global::System.IntPtr destroyPluginFunc, global::System.IntPtr onMessagePluginFunc, global::System.IntPtr saveDataForPluginReloadFunc, global::System.IntPtr loadDataAfterPluginReloadFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CPluginInfo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??1CPluginInfo@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?FromPluginInfo@CPluginInfo@@SA?AV1@PAUPluginInfo@@@Z")]
            internal static extern void FromPluginInfo_0(global::System.IntPtr @return, global::System.IntPtr pluginInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Name@CPluginInfo@@QAEXPBD@Z")]
            internal static extern void Name_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Name@CPluginInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Name_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Service@CPluginInfo@@QAEXPBD@Z")]
            internal static extern void Service_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string service);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Service@CPluginInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Service_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?CreateFunc@CPluginInfo@@QAEXP6APAXPAUModuleInfo@@HPAX@Z@Z")]
            internal static extern void CreateFunc_0(global::System.IntPtr instance, global::System.IntPtr createPluginFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?CreateFunc@CPluginInfo@@QBEP6APAXPAUModuleInfo@@HPAX@ZXZ")]
            internal static extern global::System.IntPtr CreateFunc_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?DestroyFunc@CPluginInfo@@QAEXP6AXPAX@Z@Z")]
            internal static extern void DestroyFunc_0(global::System.IntPtr instance, global::System.IntPtr destroyPluginFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?DestroyFunc@CPluginInfo@@QBEP6AXPAX@ZXZ")]
            internal static extern global::System.IntPtr DestroyFunc_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?OnMessageFunc@CPluginInfo@@QAEXP6A_NPAXPBD0@Z@Z")]
            internal static extern void OnMessageFunc_0(global::System.IntPtr instance, global::System.IntPtr onMessagePluginFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?OnMessageFunc@CPluginInfo@@QBEP6A_NPAXPBD0@ZXZ")]
            internal static extern global::System.IntPtr OnMessageFunc_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?SaveDataForReloadFunc@CPluginInfo@@QAEXP6APBDPAX@Z@Z")]
            internal static extern void SaveDataForReloadFunc_0(global::System.IntPtr instance, global::System.IntPtr saveDataForPluginReloadFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?SaveDataForReloadFunc@CPluginInfo@@QBEP6APBDPAX@ZXZ")]
            internal static extern global::System.IntPtr SaveDataForReloadFunc_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?LoadDataAfterReloadFunc@CPluginInfo@@QAEXP6AXPAXPBD@Z@Z")]
            internal static extern void LoadDataAfterReloadFunc_0(global::System.IntPtr instance, global::System.IntPtr loadDataAfterPluginReloadFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?LoadDataAfterReloadFunc@CPluginInfo@@QBEP6AXPAXPBD@ZXZ")]
            internal static extern global::System.IntPtr LoadDataAfterReloadFunc_1(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CPluginInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CPluginInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CPluginInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CPluginInfo(native.ToPointer(), skipVTables);
        }

        public static CPluginInfo __CreateInstance(CPluginInfo.__Internal native, bool skipVTables = false)
        {
            return new CPluginInfo(native, skipVTables);
        }

        private static void* __CopyValue(CPluginInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            CPluginInfo.__Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CPluginInfo(CPluginInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CPluginInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CPluginInfo(PluginInfo pluginInfo)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(pluginInfo, null) ? global::System.IntPtr.Zero : pluginInfo.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public CPluginInfo()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment));
        }

        public CPluginInfo(string name, string service, CreatePluginFunc createPluginFunc, DestroyPluginFunc destroyPluginFunc, OnMessagePluginFunc onMessagePluginFunc, SaveDataForPluginReloadFunc saveDataForPluginReloadFunc, LoadDataAfterPluginReloadFunc loadDataAfterPluginReloadFunc)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg2 = createPluginFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(createPluginFunc);
            var __arg3 = destroyPluginFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(destroyPluginFunc);
            var __arg4 = onMessagePluginFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(onMessagePluginFunc);
            var __arg5 = saveDataForPluginReloadFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(saveDataForPluginReloadFunc);
            var __arg6 = loadDataAfterPluginReloadFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(loadDataAfterPluginReloadFunc);
            __Internal.ctor_2((__Instance + __PointerAdjustment), name, service, __arg2, __arg3, __arg4, __arg5, __arg6);
        }

        public CPluginInfo(CPluginInfo src)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = src.__Instance;
            __Internal.cctor_3((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            CPluginInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Name(string name)
        {
            __Internal.Name_0((__Instance + __PointerAdjustment), name);
        }

        public string Name()
        {
            var __ret = __Internal.Name_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void Service(string service)
        {
            __Internal.Service_0((__Instance + __PointerAdjustment), service);
        }

        public string Service()
        {
            var __ret = __Internal.Service_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void CreateFunc(CreatePluginFunc createPluginFunc)
        {
            var __arg0 = createPluginFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(createPluginFunc);
            __Internal.CreateFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public CreatePluginFunc CreateFunc()
        {
            var __ret = __Internal.CreateFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (CreatePluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(CreatePluginFunc));
        }

        public void DestroyFunc(DestroyPluginFunc destroyPluginFunc)
        {
            var __arg0 = destroyPluginFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(destroyPluginFunc);
            __Internal.DestroyFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public DestroyPluginFunc DestroyFunc()
        {
            var __ret = __Internal.DestroyFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (DestroyPluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(DestroyPluginFunc));
        }

        public void OnMessageFunc(OnMessagePluginFunc onMessagePluginFunc)
        {
            var __arg0 = onMessagePluginFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(onMessagePluginFunc);
            __Internal.OnMessageFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public OnMessagePluginFunc OnMessageFunc()
        {
            var __ret = __Internal.OnMessageFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (OnMessagePluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(OnMessagePluginFunc));
        }

        public void SaveDataForReloadFunc(SaveDataForPluginReloadFunc saveDataForPluginReloadFunc)
        {
            var __arg0 = saveDataForPluginReloadFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(saveDataForPluginReloadFunc);
            __Internal.SaveDataForReloadFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public SaveDataForPluginReloadFunc SaveDataForReloadFunc()
        {
            var __ret = __Internal.SaveDataForReloadFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (SaveDataForPluginReloadFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(SaveDataForPluginReloadFunc));
        }

        public void LoadDataAfterReloadFunc(LoadDataAfterPluginReloadFunc loadDataAfterPluginReloadFunc)
        {
            var __arg0 = loadDataAfterPluginReloadFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(loadDataAfterPluginReloadFunc);
            __Internal.LoadDataAfterReloadFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public LoadDataAfterPluginReloadFunc LoadDataAfterReloadFunc()
        {
            var __ret = __Internal.LoadDataAfterReloadFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (LoadDataAfterPluginReloadFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(LoadDataAfterPluginReloadFunc));
        }

        public static implicit operator CPluginInfo(PluginInfo pluginInfo)
        {
            return new CPluginInfo(pluginInfo);
        }

        public static CPluginInfo FromPluginInfo(PluginInfo pluginInfo)
        {
            var __arg0 = ReferenceEquals(pluginInfo, null) ? global::System.IntPtr.Zero : pluginInfo.__Instance;
            var __ret = new CPluginInfo.__Internal();
            __Internal.FromPluginInfo_0(new IntPtr(&__ret), __arg0);
            return CPluginInfo.__CreateInstance(__ret);
        }
    }

    public unsafe partial class CCreatedPlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public byte _ownsInfos;

            [FieldOffset(4)]
            public global::System.IntPtr _createdPlugin;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CCreatedPlugin@@QAE@PAUCreatedPlugin@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr createdPlugin);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CCreatedPlugin@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??1CCreatedPlugin@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?FromCreatedPlugin@CCreatedPlugin@@SA?AV1@PAUCreatedPlugin@@@Z")]
            internal static extern void FromCreatedPlugin_0(global::System.IntPtr @return, global::System.IntPtr createdPlugin);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Destroy@CCreatedPlugin@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?SendMessage@CCreatedPlugin@@QAE_NPBDPAX@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SendMessage_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string messageName, global::System.IntPtr messageData);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CCreatedPlugin> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CCreatedPlugin>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CCreatedPlugin __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CCreatedPlugin(native.ToPointer(), skipVTables);
        }

        public static CCreatedPlugin __CreateInstance(CCreatedPlugin.__Internal native, bool skipVTables = false)
        {
            return new CCreatedPlugin(native, skipVTables);
        }

        private static void* __CopyValue(CCreatedPlugin.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            CCreatedPlugin.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CCreatedPlugin(CCreatedPlugin.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CCreatedPlugin(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CCreatedPlugin(CreatedPlugin createdPlugin)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(createdPlugin, null) ? global::System.IntPtr.Zero : createdPlugin.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public CCreatedPlugin(CCreatedPlugin src)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = src.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            CCreatedPlugin __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool Destroy()
        {
            var __ret = __Internal.Destroy_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool SendMessage(string messageName, global::System.IntPtr messageData)
        {
            var __ret = __Internal.SendMessage_0((__Instance + __PointerAdjustment), messageName, messageData);
            return __ret;
        }

        public static implicit operator CCreatedPlugin(CreatedPlugin createdPlugin)
        {
            return new CCreatedPlugin(createdPlugin);
        }

        public static CCreatedPlugin FromCreatedPlugin(CreatedPlugin createdPlugin)
        {
            var __arg0 = ReferenceEquals(createdPlugin, null) ? global::System.IntPtr.Zero : createdPlugin.__Instance;
            var __ret = new CCreatedPlugin.__Internal();
            __Internal.FromCreatedPlugin_0(new IntPtr(&__ret), __arg0);
            return CCreatedPlugin.__CreateInstance(__ret);
        }
    }

    public unsafe partial class CModuleDependencyInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public byte _ownsInfos;

            [FieldOffset(4)]
            public global::System.IntPtr _moduleDependencyInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CModuleDependencyInfo@@QAE@PAUModuleDependencyInfo@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr moduleDependencyInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CModuleDependencyInfo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??1CModuleDependencyInfo@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?FromModuleDependencyInfo@CModuleDependencyInfo@@SA?AV1@PAUModuleDependencyInfo@@@Z")]
            internal static extern void FromModuleDependencyInfo_0(global::System.IntPtr @return, global::System.IntPtr moduleDependencyInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Version@CModuleDependencyInfo@@QBEXAAH000@Z")]
            internal static extern void Version_0(global::System.IntPtr instance, int* major, int* minor, int* patch, int* flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Name@CModuleDependencyInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Name_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CModuleDependencyInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CModuleDependencyInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CModuleDependencyInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CModuleDependencyInfo(native.ToPointer(), skipVTables);
        }

        public static CModuleDependencyInfo __CreateInstance(CModuleDependencyInfo.__Internal native, bool skipVTables = false)
        {
            return new CModuleDependencyInfo(native, skipVTables);
        }

        private static void* __CopyValue(CModuleDependencyInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            CModuleDependencyInfo.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CModuleDependencyInfo(CModuleDependencyInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CModuleDependencyInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CModuleDependencyInfo(ModuleDependencyInfo moduleDependencyInfo)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(moduleDependencyInfo, null) ? global::System.IntPtr.Zero : moduleDependencyInfo.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public CModuleDependencyInfo(CModuleDependencyInfo src)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = src.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            CModuleDependencyInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Version(ref int major, ref int minor, ref int patch, ref int flags)
        {
            fixed (int* __refParamPtr0 = &major)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &minor)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (int* __refParamPtr2 = &patch)
                    {
                        var __arg2 = __refParamPtr2;
                        fixed (int* __refParamPtr3 = &flags)
                        {
                            var __arg3 = __refParamPtr3;
                            __Internal.Version_0((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
                        }
                    }
                }
            }
        }

        public static implicit operator CModuleDependencyInfo(ModuleDependencyInfo moduleDependencyInfo)
        {
            return new CModuleDependencyInfo(moduleDependencyInfo);
        }

        public static CModuleDependencyInfo FromModuleDependencyInfo(ModuleDependencyInfo moduleDependencyInfo)
        {
            var __arg0 = ReferenceEquals(moduleDependencyInfo, null) ? global::System.IntPtr.Zero : moduleDependencyInfo.__Instance;
            var __ret = new CModuleDependencyInfo.__Internal();
            __Internal.FromModuleDependencyInfo_0(new IntPtr(&__ret), __arg0);
            return CModuleDependencyInfo.__CreateInstance(__ret);
        }

        public string Name
        {
            get
            {
                var __ret = __Internal.Name_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }
    }

    public unsafe partial class CModuleInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public byte _ownsInfos;

            [FieldOffset(4)]
            public global::System.IntPtr _moduleInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CModuleInfo@@QAE@PAUModuleInfo@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr moduleInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CModuleInfo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CModuleInfo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??1CModuleInfo@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?FromModuleInfo@CModuleInfo@@SA?AV1@PAUModuleInfo@@@Z")]
            internal static extern void FromModuleInfo_0(global::System.IntPtr @return, global::System.IntPtr moduleInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Name@CModuleInfo@@QAEXPBD@Z")]
            internal static extern void Name_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Name@CModuleInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Name_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Type@CModuleInfo@@QAEXW4ModuleType@@@Z")]
            internal static extern void Type_0(global::System.IntPtr instance, ModuleType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Type@CModuleInfo@@QBE?AW4ModuleType@@XZ")]
            internal static extern ModuleType Type_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Description@CModuleInfo@@QAEXPBD@Z")]
            internal static extern void Description_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Description@CModuleInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Description_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Author@CModuleInfo@@QAEXPBD@Z")]
            internal static extern void Author_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string author);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Author@CModuleInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Author_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Website@CModuleInfo@@QAEXPBD@Z")]
            internal static extern void Website_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string website);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Website@CModuleInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Website_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Issues@CModuleInfo@@QAEXPBD@Z")]
            internal static extern void Issues_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string issues);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?Issues@CModuleInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr Issues_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?License@CModuleInfo@@QAEXPBD@Z")]
            internal static extern void License_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string license);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?License@CModuleInfo@@QBEPBDXZ")]
            internal static extern global::System.IntPtr License_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?SetVersion@CModuleInfo@@QAEXHHH@Z")]
            internal static extern void SetVersion_0(global::System.IntPtr instance, int major, int minor, int patch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?GetVersion@CModuleInfo@@QBEXAAH00@Z")]
            internal static extern void GetVersion_0(global::System.IntPtr instance, int* major, int* minor, int* patch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?CreatePlugin@CModuleInfo@@QAE?AVCCreatedPlugin@@PBDPAX@Z")]
            internal static extern void CreatePlugin_0(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string pluginName, global::System.IntPtr creationData);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CModuleInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CModuleInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CModuleInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CModuleInfo(native.ToPointer(), skipVTables);
        }

        public static CModuleInfo __CreateInstance(CModuleInfo.__Internal native, bool skipVTables = false)
        {
            return new CModuleInfo(native, skipVTables);
        }

        private static void* __CopyValue(CModuleInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            CModuleInfo.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CModuleInfo(CModuleInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CModuleInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CModuleInfo(ModuleInfo moduleInfo)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(moduleInfo, null) ? global::System.IntPtr.Zero : moduleInfo.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public CModuleInfo()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment));
        }

        public CModuleInfo(CModuleInfo src)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = src.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            CModuleInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Name(string name)
        {
            __Internal.Name_0((__Instance + __PointerAdjustment), name);
        }

        public string Name()
        {
            var __ret = __Internal.Name_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void Type(ModuleType type)
        {
            __Internal.Type_0((__Instance + __PointerAdjustment), type);
        }

        public ModuleType Type()
        {
            var __ret = __Internal.Type_1((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void Description(string description)
        {
            __Internal.Description_0((__Instance + __PointerAdjustment), description);
        }

        public string Description()
        {
            var __ret = __Internal.Description_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void Author(string author)
        {
            __Internal.Author_0((__Instance + __PointerAdjustment), author);
        }

        public string Author()
        {
            var __ret = __Internal.Author_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void Website(string website)
        {
            __Internal.Website_0((__Instance + __PointerAdjustment), website);
        }

        public string Website()
        {
            var __ret = __Internal.Website_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void Issues(string issues)
        {
            __Internal.Issues_0((__Instance + __PointerAdjustment), issues);
        }

        public string Issues()
        {
            var __ret = __Internal.Issues_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void License(string license)
        {
            __Internal.License_0((__Instance + __PointerAdjustment), license);
        }

        public string License()
        {
            var __ret = __Internal.License_1((__Instance + __PointerAdjustment));
            return Marshal.PtrToStringAnsi(__ret);
        }

        public void SetVersion(int major, int minor, int patch)
        {
            __Internal.SetVersion_0((__Instance + __PointerAdjustment), major, minor, patch);
        }

        public void GetVersion(ref int major, ref int minor, ref int patch)
        {
            fixed (int* __refParamPtr0 = &major)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &minor)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (int* __refParamPtr2 = &patch)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GetVersion_0((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public CCreatedPlugin CreatePlugin(string pluginName, global::System.IntPtr creationData)
        {
            var __ret = new CCreatedPlugin.__Internal();
            __Internal.CreatePlugin_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), pluginName, creationData);
            return CCreatedPlugin.__CreateInstance(__ret);
        }

        public static implicit operator CModuleInfo(ModuleInfo moduleInfo)
        {
            return new CModuleInfo(moduleInfo);
        }

        public static CModuleInfo FromModuleInfo(ModuleInfo moduleInfo)
        {
            var __arg0 = ReferenceEquals(moduleInfo, null) ? global::System.IntPtr.Zero : moduleInfo.__Instance;
            var __ret = new CModuleInfo.__Internal();
            __Internal.FromModuleInfo_0(new IntPtr(&__ret), __arg0);
            return CModuleInfo.__CreateInstance(__ret);
        }
    }

    public unsafe partial class CLoadModuleResult : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public LoadModuleResult.__Internal _loadModuleResult;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CLoadModuleResult@@QAE@P6AHXZ0@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr reloadModuleFunc, global::System.IntPtr unloadModuleFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CLoadModuleResult@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??1CLoadModuleResult@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?ReloadModuleFunc@CLoadModuleResult@@QAEXP6AHXZ@Z")]
            internal static extern void ReloadModuleFunc_0(global::System.IntPtr instance, global::System.IntPtr reloadModuleFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?ReloadModuleFunc@CLoadModuleResult@@QBEP6AHXZXZ")]
            internal static extern global::System.IntPtr ReloadModuleFunc_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?UnloadModuleFunc@CLoadModuleResult@@QAEXP6AHXZ@Z")]
            internal static extern void UnloadModuleFunc_0(global::System.IntPtr instance, global::System.IntPtr unloadModuleFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "?UnloadModuleFunc@CLoadModuleResult@@QBEP6AHXZXZ")]
            internal static extern global::System.IntPtr UnloadModuleFunc_1(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CLoadModuleResult> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CLoadModuleResult>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CLoadModuleResult __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CLoadModuleResult(native.ToPointer(), skipVTables);
        }

        public static CLoadModuleResult __CreateInstance(CLoadModuleResult.__Internal native, bool skipVTables = false)
        {
            return new CLoadModuleResult(native, skipVTables);
        }

        private static void* __CopyValue(CLoadModuleResult.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            CLoadModuleResult.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CLoadModuleResult(CLoadModuleResult.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CLoadModuleResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CLoadModuleResult(ReloadModuleFunc reloadModuleFunc, UnloadModuleFunc unloadModuleFunc)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = reloadModuleFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(reloadModuleFunc);
            var __arg1 = unloadModuleFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(unloadModuleFunc);
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public CLoadModuleResult(CLoadModuleResult src)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = src.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            CLoadModuleResult __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void ReloadModuleFunc(ReloadModuleFunc reloadModuleFunc)
        {
            var __arg0 = reloadModuleFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(reloadModuleFunc);
            __Internal.ReloadModuleFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public ReloadModuleFunc ReloadModuleFunc()
        {
            var __ret = __Internal.ReloadModuleFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (ReloadModuleFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(ReloadModuleFunc));
        }

        public void UnloadModuleFunc(UnloadModuleFunc unloadModuleFunc)
        {
            var __arg0 = unloadModuleFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(unloadModuleFunc);
            __Internal.UnloadModuleFunc_0((__Instance + __PointerAdjustment), __arg0);
        }

        public UnloadModuleFunc UnloadModuleFunc()
        {
            var __ret = __Internal.UnloadModuleFunc_1((__Instance + __PointerAdjustment));
            var __ptr0 = __ret;
            return (UnloadModuleFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(UnloadModuleFunc));
        }
    }

    public enum ModuleType
    {
        MTNotValid = 0,
        MTManaged = 1,
        MTUnmanaged = 2
    }

    public enum ArchType
    {
        ATNotValid = 0,
        ATX86 = 1,
        ATX64 = 2,
        ATAll = 3
    }

    public enum OperatingSystem
    {
        OSNotValid = 0,
        OSWindows = 1,
        OSMac = 2,
        OSLinux = 3,
        OSAll = 4
    }

    /// <summary>
    /// <para>Used enumerations </para>
    /// </summary>
    [Flags]
    public enum ModuleDependencyVersionType
    {
        MDVTAny = 0,
        /// <summary>Any version of the module can be used</summary>
        MDVTCheckMajor = 1,
        /// <summary>Only the versions with the same major release number can be used</summary>
        MDVTCheckMinor = 2,
        /// <summary>Only the versions with the same minor release number can be used</summary>
        MDVTCheckPatch = 4
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr ModuleCreatePluginFunc(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string _1, global::System.IntPtr _2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool ModuleDestroyPluginFunc(global::System.IntPtr _0, global::System.IntPtr _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool ModuleSendMessageToPluginFunc(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string _1, global::System.IntPtr _2);

    /// <summary>
    /// <para>Plugin functions </para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr CreatePluginFunc(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void DestroyPluginFunc(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool OnMessagePluginFunc(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string _1, global::System.IntPtr _2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr SaveDataForPluginReloadFunc(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LoadDataAfterPluginReloadFunc(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string _1);

    /// <summary>
    /// <para>Module functions </para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int UnloadModuleFunc();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int ReloadModuleFunc();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate LoadModuleResult.__Internal LoadModuleFunc();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool GetRegisteredPluginsFunc(global::System.IntPtr _0, int* _1);

    /// <summary>
    /// <para>Forward declaration of used types </para>
    /// </summary>
    public unsafe partial class PluginInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr _name;

            [FieldOffset(4)]
            public global::System.IntPtr _service;

            [FieldOffset(8)]
            public global::System.IntPtr _createPluginFunc;

            [FieldOffset(12)]
            public global::System.IntPtr _destroyPluginFunc;

            [FieldOffset(16)]
            public global::System.IntPtr _onMessagePluginFunc;

            [FieldOffset(20)]
            public global::System.IntPtr _saveDataForPluginReloadFunc;

            [FieldOffset(24)]
            public global::System.IntPtr _loadDataAfterPluginReloadFunc;

            [FieldOffset(28)]
            public global::System.IntPtr _reserved_module;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0PluginInfo@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PluginInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PluginInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static PluginInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new PluginInfo(native.ToPointer(), skipVTables);
        }

        public static PluginInfo __CreateInstance(PluginInfo.__Internal native, bool skipVTables = false)
        {
            return new PluginInfo(native, skipVTables);
        }

        private static void* __CopyValue(PluginInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            *(PluginInfo.__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PluginInfo(PluginInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PluginInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PluginInfo()
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PluginInfo(PluginInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((PluginInfo.__Internal*)__Instance) = *((PluginInfo.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            PluginInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public sbyte* Name
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_name;
            }

            set
            {
                ((__Internal*)__Instance)->_name = (global::System.IntPtr)value;
            }
        }

        public sbyte* Service
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_service;
            }

            set
            {
                ((__Internal*)__Instance)->_service = (global::System.IntPtr)value;
            }
        }

        public CreatePluginFunc CreatePluginFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_createPluginFunc;
                return (CreatePluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(CreatePluginFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_createPluginFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public DestroyPluginFunc DestroyPluginFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_destroyPluginFunc;
                return (DestroyPluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(DestroyPluginFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_destroyPluginFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public OnMessagePluginFunc OnMessagePluginFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_onMessagePluginFunc;
                return (OnMessagePluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(OnMessagePluginFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_onMessagePluginFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public SaveDataForPluginReloadFunc SaveDataForPluginReloadFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_saveDataForPluginReloadFunc;
                return (SaveDataForPluginReloadFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(SaveDataForPluginReloadFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_saveDataForPluginReloadFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public LoadDataAfterPluginReloadFunc LoadDataAfterPluginReloadFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_loadDataAfterPluginReloadFunc;
                return (LoadDataAfterPluginReloadFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(LoadDataAfterPluginReloadFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_loadDataAfterPluginReloadFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr ReservedModule
        {
            get
            {
                return ((__Internal*)__Instance)->_reserved_module;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_module = (global::System.IntPtr)value;
            }
        }
    }

    public unsafe partial class CreatedPlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr _reserved_plugin;

            [FieldOffset(4)]
            public global::System.IntPtr _reserved_module_info;

            [FieldOffset(8)]
            public global::System.IntPtr _reserved_plugin_info;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0CreatedPlugin@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CreatedPlugin> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CreatedPlugin>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CreatedPlugin __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CreatedPlugin(native.ToPointer(), skipVTables);
        }

        public static CreatedPlugin __CreateInstance(CreatedPlugin.__Internal native, bool skipVTables = false)
        {
            return new CreatedPlugin(native, skipVTables);
        }

        private static void* __CopyValue(CreatedPlugin.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            *(CreatedPlugin.__Internal*)ret = native;
            return ret.ToPointer();
        }

        private CreatedPlugin(CreatedPlugin.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CreatedPlugin(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CreatedPlugin()
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public CreatedPlugin(CreatedPlugin _0)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((CreatedPlugin.__Internal*)__Instance) = *((CreatedPlugin.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            CreatedPlugin __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::System.IntPtr ReservedPlugin
        {
            get
            {
                return ((__Internal*)__Instance)->_reserved_plugin;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_plugin = (global::System.IntPtr)value;
            }
        }

        public ModuleInfo ReservedModuleInfo
        {
            get
            {
                ModuleInfo __result0;
                if (((__Internal*)__Instance)->_reserved_module_info == IntPtr.Zero) __result0 = null;
                else if (ModuleInfo.NativeToManagedMap.ContainsKey(((__Internal*)__Instance)->_reserved_module_info))
                    __result0 = (ModuleInfo)ModuleInfo.NativeToManagedMap[((__Internal*)__Instance)->_reserved_module_info];
                else __result0 = ModuleInfo.__CreateInstance(((__Internal*)__Instance)->_reserved_module_info);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_module_info = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public PluginInfo ReservedPluginInfo
        {
            get
            {
                PluginInfo __result0;
                if (((__Internal*)__Instance)->_reserved_plugin_info == IntPtr.Zero) __result0 = null;
                else if (PluginInfo.NativeToManagedMap.ContainsKey(((__Internal*)__Instance)->_reserved_plugin_info))
                    __result0 = (PluginInfo)PluginInfo.NativeToManagedMap[((__Internal*)__Instance)->_reserved_plugin_info];
                else __result0 = PluginInfo.__CreateInstance(((__Internal*)__Instance)->_reserved_plugin_info);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_plugin_info = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ModuleDependencyInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr _name;

            [FieldOffset(4)]
            public int _versionMajor;

            [FieldOffset(8)]
            public int _versionMinor;

            [FieldOffset(12)]
            public int _versionPatch;

            [FieldOffset(16)]
            public int _versionDependencyFlag;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0ModuleDependencyInfo@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ModuleDependencyInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ModuleDependencyInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static ModuleDependencyInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ModuleDependencyInfo(native.ToPointer(), skipVTables);
        }

        public static ModuleDependencyInfo __CreateInstance(ModuleDependencyInfo.__Internal native, bool skipVTables = false)
        {
            return new ModuleDependencyInfo(native, skipVTables);
        }

        private static void* __CopyValue(ModuleDependencyInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            *(ModuleDependencyInfo.__Internal*)ret = native;
            return ret.ToPointer();
        }

        private ModuleDependencyInfo(ModuleDependencyInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleDependencyInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleDependencyInfo()
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ModuleDependencyInfo(ModuleDependencyInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((ModuleDependencyInfo.__Internal*)__Instance) = *((ModuleDependencyInfo.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            ModuleDependencyInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public sbyte* Name
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_name;
            }

            set
            {
                ((__Internal*)__Instance)->_name = (global::System.IntPtr)value;
            }
        }

        public int VersionMajor
        {
            get
            {
                return ((__Internal*)__Instance)->_versionMajor;
            }

            set
            {
                ((__Internal*)__Instance)->_versionMajor = value;
            }
        }

        public int VersionMinor
        {
            get
            {
                return ((__Internal*)__Instance)->_versionMinor;
            }

            set
            {
                ((__Internal*)__Instance)->_versionMinor = value;
            }
        }

        public int VersionPatch
        {
            get
            {
                return ((__Internal*)__Instance)->_versionPatch;
            }

            set
            {
                ((__Internal*)__Instance)->_versionPatch = value;
            }
        }

        public int VersionDependencyFlag
        {
            get
            {
                return ((__Internal*)__Instance)->_versionDependencyFlag;
            }

            set
            {
                ((__Internal*)__Instance)->_versionDependencyFlag = value;
            }
        }
    }

    public unsafe partial class ModuleBinaryInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr _path;

            [FieldOffset(4)]
            public ArchType _archType;

            [FieldOffset(8)]
            public OperatingSystem _os;

            [FieldOffset(12)]
            public byte _autoCompile;

            [FieldOffset(16)]
            public global::System.IntPtr _entryPointNamespace;

            [FieldOffset(20)]
            public global::System.IntPtr _entryPointClass;

            [FieldOffset(24)]
            public global::System.IntPtr _compileCommand;

            [FieldOffset(28)]
            public global::System.IntPtr _sourceFiles;

            [FieldOffset(32)]
            public global::System.IntPtr _compiler;

            [FieldOffset(36)]
            public global::System.IntPtr _compilerArgs;

            [FieldOffset(40)]
            public global::System.IntPtr _linker;

            [FieldOffset(44)]
            public global::System.IntPtr _linkerArgs;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0ModuleBinaryInfo@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ModuleBinaryInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ModuleBinaryInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static ModuleBinaryInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ModuleBinaryInfo(native.ToPointer(), skipVTables);
        }

        public static ModuleBinaryInfo __CreateInstance(ModuleBinaryInfo.__Internal native, bool skipVTables = false)
        {
            return new ModuleBinaryInfo(native, skipVTables);
        }

        private static void* __CopyValue(ModuleBinaryInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(48);
            *(ModuleBinaryInfo.__Internal*)ret = native;
            return ret.ToPointer();
        }

        private ModuleBinaryInfo(ModuleBinaryInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleBinaryInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleBinaryInfo()
        {
            __Instance = Marshal.AllocHGlobal(48);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ModuleBinaryInfo(ModuleBinaryInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(48);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((ModuleBinaryInfo.__Internal*)__Instance) = *((ModuleBinaryInfo.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            ModuleBinaryInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public sbyte* Path
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_path;
            }

            set
            {
                ((__Internal*)__Instance)->_path = (global::System.IntPtr)value;
            }
        }

        public ArchType ArchType
        {
            get
            {
                return ((__Internal*)__Instance)->_archType;
            }

            set
            {
                ((__Internal*)__Instance)->_archType = value;
            }
        }

        public OperatingSystem Os
        {
            get
            {
                return ((__Internal*)__Instance)->_os;
            }

            set
            {
                ((__Internal*)__Instance)->_os = value;
            }
        }

        public bool AutoCompile
        {
            get
            {
                return ((__Internal*)__Instance)->_autoCompile != 0;
            }

            set
            {
                ((__Internal*)__Instance)->_autoCompile = (byte)(value ? 1 : 0);
            }
        }

        public sbyte* EntryPointNamespace
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_entryPointNamespace;
            }

            set
            {
                ((__Internal*)__Instance)->_entryPointNamespace = (global::System.IntPtr)value;
            }
        }

        public sbyte* EntryPointClass
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_entryPointClass;
            }

            set
            {
                ((__Internal*)__Instance)->_entryPointClass = (global::System.IntPtr)value;
            }
        }

        public sbyte* CompileCommand
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_compileCommand;
            }

            set
            {
                ((__Internal*)__Instance)->_compileCommand = (global::System.IntPtr)value;
            }
        }

        public sbyte* SourceFiles
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_sourceFiles;
            }

            set
            {
                ((__Internal*)__Instance)->_sourceFiles = (global::System.IntPtr)value;
            }
        }

        public sbyte* Compiler
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_compiler;
            }

            set
            {
                ((__Internal*)__Instance)->_compiler = (global::System.IntPtr)value;
            }
        }

        public sbyte* CompilerArgs
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_compilerArgs;
            }

            set
            {
                ((__Internal*)__Instance)->_compilerArgs = (global::System.IntPtr)value;
            }
        }

        public sbyte* Linker
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_linker;
            }

            set
            {
                ((__Internal*)__Instance)->_linker = (global::System.IntPtr)value;
            }
        }

        public sbyte* LinkerArgs
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_linkerArgs;
            }

            set
            {
                ((__Internal*)__Instance)->_linkerArgs = (global::System.IntPtr)value;
            }
        }
    }

    public unsafe partial class ModuleInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr _name;

            [FieldOffset(4)]
            public ModuleType _moduleType;

            [FieldOffset(8)]
            public global::System.IntPtr _binaries;

            [FieldOffset(12)]
            public int _binariesCount;

            [FieldOffset(16)]
            public global::System.IntPtr _description;

            [FieldOffset(20)]
            public global::System.IntPtr _author;

            [FieldOffset(24)]
            public global::System.IntPtr _website;

            [FieldOffset(28)]
            public global::System.IntPtr _issues;

            [FieldOffset(32)]
            public global::System.IntPtr _license;

            [FieldOffset(36)]
            public global::System.IntPtr _dependencies;

            [FieldOffset(40)]
            public int _dependenciesCount;

            [FieldOffset(44)]
            public int _versionMajor;

            [FieldOffset(48)]
            public int _versionMinor;

            [FieldOffset(52)]
            public int _versionPatch;

            [FieldOffset(56)]
            public global::System.IntPtr _reserved_module;

            [FieldOffset(60)]
            public global::System.IntPtr _reserved_createPluginFunc;

            [FieldOffset(64)]
            public global::System.IntPtr _reserved_destroyPluginFunc;

            [FieldOffset(68)]
            public global::System.IntPtr _reserved_sendMessageToPluginFunc;

            [FieldOffset(72)]
            public global::System.IntPtr _reserved_registeredPlugins;

            [FieldOffset(76)]
            public int _reserved_registeredPluginsCount;

            [FieldOffset(80)]
            public global::System.IntPtr _reserved_dependencies;

            [FieldOffset(84)]
            public int _reserved_dependenciesCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0ModuleInfo@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ModuleInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ModuleInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static ModuleInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ModuleInfo(native.ToPointer(), skipVTables);
        }

        public static ModuleInfo __CreateInstance(ModuleInfo.__Internal native, bool skipVTables = false)
        {
            return new ModuleInfo(native, skipVTables);
        }

        private static void* __CopyValue(ModuleInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(88);
            *(ModuleInfo.__Internal*)ret = native;
            return ret.ToPointer();
        }

        private ModuleInfo(ModuleInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleInfo()
        {
            __Instance = Marshal.AllocHGlobal(88);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ModuleInfo(ModuleInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(88);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((ModuleInfo.__Internal*)__Instance) = *((ModuleInfo.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            ModuleInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public sbyte* Name
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_name;
            }

            set
            {
                ((__Internal*)__Instance)->_name = (global::System.IntPtr)value;
            }
        }

        public ModuleType ModuleType
        {
            get
            {
                return ((__Internal*)__Instance)->_moduleType;
            }

            set
            {
                ((__Internal*)__Instance)->_moduleType = value;
            }
        }

        public ModuleBinaryInfo Binaries
        {
            get
            {
                ModuleBinaryInfo __result0;
                if (((__Internal*)__Instance)->_binaries == IntPtr.Zero) __result0 = null;
                else if (ModuleBinaryInfo.NativeToManagedMap.ContainsKey(((__Internal*)__Instance)->_binaries))
                    __result0 = (ModuleBinaryInfo)ModuleBinaryInfo.NativeToManagedMap[((__Internal*)__Instance)->_binaries];
                else __result0 = ModuleBinaryInfo.__CreateInstance(((__Internal*)__Instance)->_binaries);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_binaries = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int BinariesCount
        {
            get
            {
                return ((__Internal*)__Instance)->_binariesCount;
            }

            set
            {
                ((__Internal*)__Instance)->_binariesCount = value;
            }
        }

        public sbyte* Description
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_description;
            }

            set
            {
                ((__Internal*)__Instance)->_description = (global::System.IntPtr)value;
            }
        }

        public sbyte* Author
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_author;
            }

            set
            {
                ((__Internal*)__Instance)->_author = (global::System.IntPtr)value;
            }
        }

        public sbyte* Website
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_website;
            }

            set
            {
                ((__Internal*)__Instance)->_website = (global::System.IntPtr)value;
            }
        }

        public sbyte* Issues
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_issues;
            }

            set
            {
                ((__Internal*)__Instance)->_issues = (global::System.IntPtr)value;
            }
        }

        public sbyte* License
        {
            get
            {
                return (sbyte*)((__Internal*)__Instance)->_license;
            }

            set
            {
                ((__Internal*)__Instance)->_license = (global::System.IntPtr)value;
            }
        }

        public ModuleDependencyInfo Dependencies
        {
            get
            {
                ModuleDependencyInfo __result0;
                if (((__Internal*)__Instance)->_dependencies == IntPtr.Zero) __result0 = null;
                else if (ModuleDependencyInfo.NativeToManagedMap.ContainsKey(((__Internal*)__Instance)->_dependencies))
                    __result0 = (ModuleDependencyInfo)ModuleDependencyInfo.NativeToManagedMap[((__Internal*)__Instance)->_dependencies];
                else __result0 = ModuleDependencyInfo.__CreateInstance(((__Internal*)__Instance)->_dependencies);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_dependencies = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int DependenciesCount
        {
            get
            {
                return ((__Internal*)__Instance)->_dependenciesCount;
            }

            set
            {
                ((__Internal*)__Instance)->_dependenciesCount = value;
            }
        }

        public int VersionMajor
        {
            get
            {
                return ((__Internal*)__Instance)->_versionMajor;
            }

            set
            {
                ((__Internal*)__Instance)->_versionMajor = value;
            }
        }

        public int VersionMinor
        {
            get
            {
                return ((__Internal*)__Instance)->_versionMinor;
            }

            set
            {
                ((__Internal*)__Instance)->_versionMinor = value;
            }
        }

        public int VersionPatch
        {
            get
            {
                return ((__Internal*)__Instance)->_versionPatch;
            }

            set
            {
                ((__Internal*)__Instance)->_versionPatch = value;
            }
        }

        public global::System.IntPtr ReservedModule
        {
            get
            {
                return ((__Internal*)__Instance)->_reserved_module;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_module = (global::System.IntPtr)value;
            }
        }

        public ModuleCreatePluginFunc ReservedCreatePluginFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_reserved_createPluginFunc;
                return (ModuleCreatePluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(ModuleCreatePluginFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_createPluginFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public ModuleDestroyPluginFunc ReservedDestroyPluginFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_reserved_destroyPluginFunc;
                return (ModuleDestroyPluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(ModuleDestroyPluginFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_destroyPluginFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public ModuleSendMessageToPluginFunc ReservedSendMessageToPluginFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_reserved_sendMessageToPluginFunc;
                return (ModuleSendMessageToPluginFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(ModuleSendMessageToPluginFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_sendMessageToPluginFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public PluginInfo ReservedRegisteredPlugins
        {
            get
            {
                PluginInfo __result0;
                if (((__Internal*)__Instance)->_reserved_registeredPlugins == IntPtr.Zero) __result0 = null;
                else if (PluginInfo.NativeToManagedMap.ContainsKey(((__Internal*)__Instance)->_reserved_registeredPlugins))
                    __result0 = (PluginInfo)PluginInfo.NativeToManagedMap[((__Internal*)__Instance)->_reserved_registeredPlugins];
                else __result0 = PluginInfo.__CreateInstance(((__Internal*)__Instance)->_reserved_registeredPlugins);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_registeredPlugins = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int ReservedRegisteredPluginsCount
        {
            get
            {
                return ((__Internal*)__Instance)->_reserved_registeredPluginsCount;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_registeredPluginsCount = value;
            }
        }

        public ModuleInfo ReservedDependencies
        {
            get
            {
                ModuleInfo __result0;
                if (((__Internal*)__Instance)->_reserved_dependencies == IntPtr.Zero) __result0 = null;
                else if (ModuleInfo.NativeToManagedMap.ContainsKey(((__Internal*)__Instance)->_reserved_dependencies))
                    __result0 = (ModuleInfo)ModuleInfo.NativeToManagedMap[((__Internal*)__Instance)->_reserved_dependencies];
                else __result0 = ModuleInfo.__CreateInstance(((__Internal*)__Instance)->_reserved_dependencies);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_dependencies = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int ReservedDependenciesCount
        {
            get
            {
                return ((__Internal*)__Instance)->_reserved_dependenciesCount;
            }

            set
            {
                ((__Internal*)__Instance)->_reserved_dependenciesCount = value;
            }
        }
    }

    public unsafe partial class LoadModuleResult : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr _unloadModuleFunc;

            [FieldOffset(4)]
            public global::System.IntPtr _reloadModuleFunc;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint = "??0LoadModuleResult@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LoadModuleResult> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LoadModuleResult>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static LoadModuleResult __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new LoadModuleResult(native.ToPointer(), skipVTables);
        }

        public static LoadModuleResult __CreateInstance(LoadModuleResult.__Internal native, bool skipVTables = false)
        {
            return new LoadModuleResult(native, skipVTables);
        }

        private static void* __CopyValue(LoadModuleResult.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            *(LoadModuleResult.__Internal*)ret = native;
            return ret.ToPointer();
        }

        private LoadModuleResult(LoadModuleResult.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LoadModuleResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public LoadModuleResult()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public LoadModuleResult(LoadModuleResult _0)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((LoadModuleResult.__Internal*)__Instance) = *((LoadModuleResult.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            LoadModuleResult __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public UnloadModuleFunc UnloadModuleFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_unloadModuleFunc;
                return (UnloadModuleFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(UnloadModuleFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_unloadModuleFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public ReloadModuleFunc ReloadModuleFunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_reloadModuleFunc;
                return (ReloadModuleFunc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(ReloadModuleFunc));
            }

            set
            {
                ((__Internal*)__Instance)->_reloadModuleFunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ModuleTools
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "InitializeModuleDependencyInfo")]
            internal static extern void InitializeModuleDependencyInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "DestroyModuleDependencyInfo")]
            internal static extern void DestroyModuleDependencyInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "CopyModuleDependencyInfo")]
            internal static extern void CopyModuleDependencyInfo_0(global::System.IntPtr dst, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleDependencyInfoName")]
            internal static extern void SetModuleDependencyInfoName_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleDependencyInfoVersion")]
            internal static extern void SetModuleDependencyInfoVersion_0(global::System.IntPtr info, int major, int minor, int patch, int flag);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "InitializeModuleBinaryInfo")]
            internal static extern void InitializeModuleBinaryInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "DestroyModuleBinaryInfo")]
            internal static extern void DestroyModuleBinaryInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "CopyModuleBinaryInfo")]
            internal static extern void CopyModuleBinaryInfo_0(global::System.IntPtr dst, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoPath")]
            internal static extern void SetModuleBinaryInfoPath_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoOperatingSystem")]
            internal static extern void SetModuleBinaryInfoOperatingSystem_0(global::System.IntPtr info, OperatingSystem value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoArchType")]
            internal static extern void SetModuleBinaryInfoArchType_0(global::System.IntPtr info, ArchType value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoAutoCompile")]
            internal static extern void SetModuleBinaryInfoAutoCompile_0(global::System.IntPtr info, bool value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoEntryPointNamespace")]
            internal static extern void SetModuleBinaryInfoEntryPointNamespace_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoEntryPointClass")]
            internal static extern void SetModuleBinaryInfoEntryPointClass_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoCompileCommand")]
            internal static extern void SetModuleBinaryInfoCompileCommand_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoSourceFiles")]
            internal static extern void SetModuleBinaryInfoSourceFiles_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoCompiler")]
            internal static extern void SetModuleBinaryInfoCompiler_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoCompilerArgs")]
            internal static extern void SetModuleBinaryInfoCompilerArgs_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoLinker")]
            internal static extern void SetModuleBinaryInfoLinker_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleBinaryInfoLinkerArgs")]
            internal static extern void SetModuleBinaryInfoLinkerArgs_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "InitializeModuleInfo")]
            internal static extern void InitializeModuleInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "DestroyModuleInfo")]
            internal static extern void DestroyModuleInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "CopyModuleInfo")]
            internal static extern void CopyModuleInfo_0(global::System.IntPtr dst, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoName")]
            internal static extern void SetModuleInfoName_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoModuleType")]
            internal static extern void SetModuleInfoModuleType_0(global::System.IntPtr info, ModuleType value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoBinaries")]
            internal static extern void SetModuleInfoBinaries_0(global::System.IntPtr info, global::System.IntPtr value, int valueCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoDescription")]
            internal static extern void SetModuleInfoDescription_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoAuthor")]
            internal static extern void SetModuleInfoAuthor_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoWebsite")]
            internal static extern void SetModuleInfoWebsite_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoIssues")]
            internal static extern void SetModuleInfoIssues_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoLicense")]
            internal static extern void SetModuleInfoLicense_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoDependencies")]
            internal static extern void SetModuleInfoDependencies_0(global::System.IntPtr info, global::System.IntPtr value, int valueCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "SetModuleInfoVersion")]
            internal static extern void SetModuleInfoVersion_0(global::System.IntPtr info, int major, int minor, int patch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?InitializePluginInfo@@YAXAAUPluginInfo@@@Z")]
            internal static extern void InitializePluginInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?DestroyPluginInfo@@YAXAAUPluginInfo@@@Z")]
            internal static extern void DestroyPluginInfo_0(global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoName@@YAXAAUPluginInfo@@PBD@Z")]
            internal static extern void SetPluginInfoName_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoService@@YAXAAUPluginInfo@@PBD@Z")]
            internal static extern void SetPluginInfoService_0(global::System.IntPtr info, [MarshalAs(UnmanagedType.LPStr)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoCreateFunction@@YAXAAUPluginInfo@@P6APAXPAUModuleInfo@@HPAX@Z@Z")]
            internal static extern void SetPluginInfoCreateFunction_0(global::System.IntPtr info, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoDestroyFunction@@YAXAAUPluginInfo@@P6AXPAX@Z@Z")]
            internal static extern void SetPluginInfoDestroyFunction_0(global::System.IntPtr info, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoSaveDataForReloadFunction@@YAXAAUPluginInfo@@P6APBDPAX@Z@Z")]
            internal static extern void SetPluginInfoSaveDataForReloadFunction_0(global::System.IntPtr info, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoLoadDataAfterReloadFunction@@YAXAAUPluginInfo@@P6AXPAXPBD@Z@Z")]
            internal static extern void SetPluginInfoLoadDataAfterReloadFunction_0(global::System.IntPtr info, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SetPluginInfoOnMessageFunction@@YAXAAUPluginInfo@@P6A_NPAXPBD1@Z@Z")]
            internal static extern void SetPluginInfoOnMessageFunction_0(global::System.IntPtr info, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?CopyPluginInfo@@YAXAAUPluginInfo@@ABU1@@Z")]
            internal static extern void CopyPluginInfo_0(global::System.IntPtr dst, global::System.IntPtr src);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?AddPluginInfo@@YAXPAPAUPluginInfo@@AAHPBD2P6APAXPAUModuleInfo@@HPAX@ZP6AX4@ZP6APBD4@ZP6AX42@ZP6A_N424@Z@Z")]
            internal static extern void AddPluginInfo_0(global::System.IntPtr infos, int* infosCount, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string service, global::System.IntPtr createFunc, global::System.IntPtr destroyFunc, global::System.IntPtr saveDataForReloadFunc, global::System.IntPtr loadDataAfterReloadFunc, global::System.IntPtr onMessageFunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?ClearPluginInfos@@YAXPAPAUPluginInfo@@AAH@Z")]
            internal static extern void ClearPluginInfos_0(global::System.IntPtr infos, int* infosCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?CreatePlugin@@YAPAUCreatedPlugin@@PAUModuleInfo@@PBDPAX@Z")]
            internal static extern global::System.IntPtr CreatePlugin_0(global::System.IntPtr module, [MarshalAs(UnmanagedType.LPStr)] string pluginName, global::System.IntPtr creationData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?DestroyPlugin@@YA_NPAUCreatedPlugin@@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DestroyPlugin_0(global::System.IntPtr plugin);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?SendMessageToPlugin@@YA_NPAUCreatedPlugin@@PBDPAX@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SendMessageToPlugin_0(global::System.IntPtr plugin, [MarshalAs(UnmanagedType.LPStr)] string messageName, global::System.IntPtr messageData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppPlug_d.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "?GetDependency@@YAPAUModuleInfo@@PAU1@HPBD@Z")]
            internal static extern global::System.IntPtr GetDependency_0(global::System.IntPtr dependencies, int dependenciesCount, [MarshalAs(UnmanagedType.LPStr)] string wantedDependencyName);
        }

        /// <summary>
        /// <para>Function to operate on ModuleDependencyInfo </para>
        /// </summary>
        public static void InitializeModuleDependencyInfo(ModuleDependencyInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.InitializeModuleDependencyInfo_0(__arg0);
        }

        public static void DestroyModuleDependencyInfo(ModuleDependencyInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.DestroyModuleDependencyInfo_0(__arg0);
        }

        public static void CopyModuleDependencyInfo(ModuleDependencyInfo dst, ModuleDependencyInfo src)
        {
            if (ReferenceEquals(dst, null))
                throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = dst.__Instance;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = src.__Instance;
            __Internal.CopyModuleDependencyInfo_0(__arg0, __arg1);
        }

        public static void SetModuleDependencyInfoName(ModuleDependencyInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleDependencyInfoName_0(__arg0, value);
        }

        public static void SetModuleDependencyInfoVersion(ModuleDependencyInfo info, int major, int minor, int patch, int flag)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleDependencyInfoVersion_0(__arg0, major, minor, patch, flag);
        }

        /// <summary>
        /// <para>Function to operate on ModuleBinaryInfo </para>
        /// </summary>
        public static void InitializeModuleBinaryInfo(ModuleBinaryInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.InitializeModuleBinaryInfo_0(__arg0);
        }

        public static void DestroyModuleBinaryInfo(ModuleBinaryInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.DestroyModuleBinaryInfo_0(__arg0);
        }

        public static void CopyModuleBinaryInfo(ModuleBinaryInfo dst, ModuleBinaryInfo src)
        {
            if (ReferenceEquals(dst, null))
                throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = dst.__Instance;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = src.__Instance;
            __Internal.CopyModuleBinaryInfo_0(__arg0, __arg1);
        }

        public static void SetModuleBinaryInfoPath(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoPath_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoOperatingSystem(ModuleBinaryInfo info, OperatingSystem value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoOperatingSystem_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoArchType(ModuleBinaryInfo info, ArchType value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoArchType_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoAutoCompile(ModuleBinaryInfo info, bool value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoAutoCompile_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoEntryPointNamespace(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoEntryPointNamespace_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoEntryPointClass(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoEntryPointClass_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoCompileCommand(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoCompileCommand_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoSourceFiles(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoSourceFiles_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoCompiler(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoCompiler_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoCompilerArgs(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoCompilerArgs_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoLinker(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoLinker_0(__arg0, value);
        }

        public static void SetModuleBinaryInfoLinkerArgs(ModuleBinaryInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleBinaryInfoLinkerArgs_0(__arg0, value);
        }

        /// <summary>
        /// <para>Function to operate on ModuleInfo </para>
        /// </summary>
        public static void InitializeModuleInfo(ModuleInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.InitializeModuleInfo_0(__arg0);
        }

        public static void DestroyModuleInfo(ModuleInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.DestroyModuleInfo_0(__arg0);
        }

        public static void CopyModuleInfo(ModuleInfo dst, ModuleInfo src)
        {
            if (ReferenceEquals(dst, null))
                throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = dst.__Instance;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = src.__Instance;
            __Internal.CopyModuleInfo_0(__arg0, __arg1);
        }

        public static void SetModuleInfoName(ModuleInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoName_0(__arg0, value);
        }

        public static void SetModuleInfoModuleType(ModuleInfo info, ModuleType value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoModuleType_0(__arg0, value);
        }

        public static void SetModuleInfoBinaries(ModuleInfo info, ModuleBinaryInfo value, int valueCount)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            __Internal.SetModuleInfoBinaries_0(__arg0, __arg1, valueCount);
        }

        public static void SetModuleInfoDescription(ModuleInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoDescription_0(__arg0, value);
        }

        public static void SetModuleInfoAuthor(ModuleInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoAuthor_0(__arg0, value);
        }

        public static void SetModuleInfoWebsite(ModuleInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoWebsite_0(__arg0, value);
        }

        public static void SetModuleInfoIssues(ModuleInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoIssues_0(__arg0, value);
        }

        public static void SetModuleInfoLicense(ModuleInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoLicense_0(__arg0, value);
        }

        public static void SetModuleInfoDependencies(ModuleInfo info, ModuleDependencyInfo value, int valueCount)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            __Internal.SetModuleInfoDependencies_0(__arg0, __arg1, valueCount);
        }

        public static void SetModuleInfoVersion(ModuleInfo info, int major, int minor, int patch)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetModuleInfoVersion_0(__arg0, major, minor, patch);
        }

        /// <summary>
        /// <para>Functions to operate on PluginInfo</para>
        /// </summary>
        public static void InitializePluginInfo(PluginInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.InitializePluginInfo_0(__arg0);
        }

        public static void DestroyPluginInfo(PluginInfo info)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.DestroyPluginInfo_0(__arg0);
        }

        public static void SetPluginInfoName(PluginInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetPluginInfoName_0(__arg0, value);
        }

        public static void SetPluginInfoService(PluginInfo info, string value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            __Internal.SetPluginInfoService_0(__arg0, value);
        }

        public static void SetPluginInfoCreateFunction(PluginInfo info, CreatePluginFunc value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            __Internal.SetPluginInfoCreateFunction_0(__arg0, __arg1);
        }

        public static void SetPluginInfoDestroyFunction(PluginInfo info, DestroyPluginFunc value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            __Internal.SetPluginInfoDestroyFunction_0(__arg0, __arg1);
        }

        public static void SetPluginInfoSaveDataForReloadFunction(PluginInfo info, SaveDataForPluginReloadFunc value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            __Internal.SetPluginInfoSaveDataForReloadFunction_0(__arg0, __arg1);
        }

        public static void SetPluginInfoLoadDataAfterReloadFunction(PluginInfo info, LoadDataAfterPluginReloadFunc value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            __Internal.SetPluginInfoLoadDataAfterReloadFunction_0(__arg0, __arg1);
        }

        public static void SetPluginInfoOnMessageFunction(PluginInfo info, OnMessagePluginFunc value)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = info.__Instance;
            var __arg1 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            __Internal.SetPluginInfoOnMessageFunction_0(__arg0, __arg1);
        }

        public static void CopyPluginInfo(PluginInfo dst, PluginInfo src)
        {
            if (ReferenceEquals(dst, null))
                throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = dst.__Instance;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = src.__Instance;
            __Internal.CopyPluginInfo_0(__arg0, __arg1);
        }

        public static void AddPluginInfo(PluginInfo infos, ref int infosCount, string name, string service, CreatePluginFunc createFunc, DestroyPluginFunc destroyFunc, SaveDataForPluginReloadFunc saveDataForReloadFunc, LoadDataAfterPluginReloadFunc loadDataAfterReloadFunc, OnMessagePluginFunc onMessageFunc)
        {
            var __arg0 = ReferenceEquals(infos, null) ? global::System.IntPtr.Zero : infos.__Instance;
            fixed (int* __refParamPtr1 = &infosCount)
            {
                var __arg1 = __refParamPtr1;
                var __arg4 = createFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(createFunc);
                var __arg5 = destroyFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(destroyFunc);
                var __arg6 = saveDataForReloadFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(saveDataForReloadFunc);
                var __arg7 = loadDataAfterReloadFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(loadDataAfterReloadFunc);
                var __arg8 = onMessageFunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(onMessageFunc);
                __Internal.AddPluginInfo_0(__arg0, __arg1, name, service, __arg4, __arg5, __arg6, __arg7, __arg8);
            }
        }

        public static void ClearPluginInfos(PluginInfo infos, ref int infosCount)
        {
            var __arg0 = ReferenceEquals(infos, null) ? global::System.IntPtr.Zero : infos.__Instance;
            fixed (int* __refParamPtr1 = &infosCount)
            {
                var __arg1 = __refParamPtr1;
                __Internal.ClearPluginInfos_0(__arg0, __arg1);
            }
        }

        /// <summary>
        /// <para>Functions to operate on plugins </para>
        /// </summary>
        public static CreatedPlugin CreatePlugin(ModuleInfo module, string pluginName, global::System.IntPtr creationData)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.CreatePlugin_0(__arg0, pluginName, creationData);
            CreatedPlugin __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (CreatedPlugin.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (CreatedPlugin)CreatedPlugin.NativeToManagedMap[__ret];
            else __result0 = CreatedPlugin.__CreateInstance(__ret);
            return __result0;
        }

        public static bool DestroyPlugin(CreatedPlugin plugin)
        {
            var __arg0 = ReferenceEquals(plugin, null) ? global::System.IntPtr.Zero : plugin.__Instance;
            var __ret = __Internal.DestroyPlugin_0(__arg0);
            return __ret;
        }

        public static bool SendMessageToPlugin(CreatedPlugin plugin, string messageName, global::System.IntPtr messageData)
        {
            var __arg0 = ReferenceEquals(plugin, null) ? global::System.IntPtr.Zero : plugin.__Instance;
            var __ret = __Internal.SendMessageToPlugin_0(__arg0, messageName, messageData);
            return __ret;
        }

        /// <summary>
        /// <para>Functions to operate on module's dependencies </para>
        /// </summary>
        public static ModuleInfo GetDependency(ModuleInfo dependencies, int dependenciesCount, string wantedDependencyName)
        {
            var __arg0 = ReferenceEquals(dependencies, null) ? global::System.IntPtr.Zero : dependencies.__Instance;
            var __ret = __Internal.GetDependency_0(__arg0, dependenciesCount, wantedDependencyName);
            ModuleInfo __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (ModuleInfo.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (ModuleInfo)ModuleInfo.NativeToManagedMap[__ret];
            else __result0 = ModuleInfo.__CreateInstance(__ret);
            return __result0;
        }
    }
}
